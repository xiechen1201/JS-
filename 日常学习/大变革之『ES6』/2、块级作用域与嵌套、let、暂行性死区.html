<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script type="text/javascript">
      /* var a = 1;
      var a = 2; */
      // 这样就会导致变量覆盖和污染，ES5通过立即执行函数来解决，但是立即执行函数内也会存在污染问题
      // ES6 新增了 let 块级作用域

      // 块代码
      /* if (1) {}
      for (var i = 0; i <script 10; i++) {} */

      // let 的特征：
      // 1、同一个作用域下不能重复声明

      // 在全局作用域下
      /* let a = 1;
      let a = 2;
      Uncaught SyntaxError: Identifier 'a' has already been declared */

      // 在函数作用域内
      /* function test() {
        let a = 1;
        let a = 2;
      } */

      // 使用 var 也不行
      /* function test() {
        let a = 1;
        var a = 2;
      } */

      // let 声明不能和形参同名
      /* function test(a) {
        let a = 2;
        console.log(a);
      }
      test(1) */

      // 不同作用域的声明
      /* function test(a) {
        {
          let a = 2;
          console.log(a); // 2
        }
        console.log(a); // 1
      }
      test(1); */

      // 2、let 不会声明提升，会产生暂时性死区

      // 全局作用域内，无法在 let 之前访问变量
      /* console.log(a); // Cannot access 'a' before initialization
      let a = 10; */

      // 函数作用域内
      /* function test() {
        console.log(a);
        let a = 10;
      }
      test(); F*/

      /* {
        let a = 1;
        function a() {}
        console.log(a); // error
      } */

      // 暂时性死区的案例
      /* var a = a;
      console.log(a); // undefind

      let b = b;
      console.log(b); // Cannot access 'b' before initialization */

      /* function test(x = y, y = 2) {
        console.log(x, y); // Cannot access 'y' before initialization
      }
      test();

      function test1(x = 2, y = x) {
        console.log(x, y); // 2 2
      }
      test1(); */

      /* console.log(typeof a); // Cannot access 'a' before initialization
      let a = 1; */

      // 3、let 只能在当前的块级作用域内生效
      /* {
        let a = 2;
      }
      console.log(a); // a is not defined */

      /* function test(){
        let a = 2;
      }
      console.log(a) */

      /* if(1){
        let a = 2;
        var b = 3;
      }
      console.log(a)
      console.log(b) */

      /* for (var i = 0; i < 3; i++) {
        let a = 1;
      }
      console.log(a); */

      // for 循环中 () 然后属于 {} 块作用域的范畴
      /* for (let i = 0; i < 3; i++) {}
      console.log(i); // i is not defined */

      /* var arr = [];
      for (var i = 0; i < 5; i++) {
        arr.push(function () {
          console.log(i);
        });
      }
      // 这里 console.log(i); 会打印 5 没有错
      // 但是下一次循环的时候 i 没覆盖了
      for (var i = 0; i < 5; i++) {
        arr[i](); // 0 1 2 3 4
      } */

      // for 循环中 () 和 {} 不是一个作用，其实是两个作用域
      // let 本质上就是为了 JS 增加一个块级作用域
      /* for (let i = 0; i < 5; i++) {
        let i = "a";
        console.log(i); // a a a a a
        // 类似 
        // {
        //     i = 0
        //     {
        //         i="a"
        //     }
        // }
      } */

      /* for (let i = 0; i < 5; i++) {
        var i = "a";
        console.log(i);  // Identifier 'i' has already been declared 
      } */

      /* 
        let 块级作用域
        {
            let i = 0;
            function () {
                console.log(i);
            }
        }
       */
      /* var arr = [];
      for (let i = 0; i < 5; i++) {
        arr.push(function () {
          console.log(i);
        });
      }
      arr.forEach((item) => {
        item();
      }); */
    </script>
  </body>
</html>
