<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>剖析JavaScript的执行机制</title>
  </head>
  <body>
    <script>
      // ## 进程
      // 是计算机的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的「基本单位」
      //（正在运行的程序就叫进程）
      // 多进程：启动多个进程，多个进程可以一块来执行多个任务

      // ##
      // 单线程：进程内一个相对独立的，可调度的执行单元；于同属的一个进程共享着进程中的资源（同一时间，只能做一件事）（例如 setTimeout、ajax）
      // 多线程：启动一个进程，在一个进程内部启动多个线程，这样多个线程也可以一块执行多个任务（也是通过调度来做的，如同多线程能做多任务一样，多线程也能做多任务）

      // 进程好比一个工厂，线程相当于工人
      // 工厂的资源：系统分配的内存（独立的一块内存）
      // 工厂之间的相互独立：进程之间相互独立
      // 多个工人协作完成任务：多个线程在进程中协作完成任务
      // 工厂内有一个或多个工人：一个进程有一个或多个线程组成

      // ===================

      /**
       * 浏览器是多进程的
       * 浏览器渲染引擎进程是其中之前
       * 浏览器渲染引擎常驻的线程：
       *    1、JS 引擎线程（单线程，避免例如两个js文件同时操作同一个DOM，就会引起混乱）（解释和执行js代码）
       *    2、GUI 线程（绘制用户界面）（和 JS 引擎是互斥的）
       *    3、http 网络请求线程
       *    4、定时器触发线程
       *    5、浏览器事件处理线程
       *
       * （3、4、5也统称 Web APIs，异步处理）
       *
       *
       * 单线程处理数据能力慢
       * 数据量大会怎么样？SRR（服务端渲染） 和 webworker（向JS单线程申请子线程，由浏览器进程开启）
       *
       * 单线程的解决方案就是异步（等待的场景）
       *
       * JS 的运行原理：JS 引擎进程是单线程，同时还执行异步（异步：同一时间处理两个事情）
       * JS 引擎通过事件驱动的方式模拟来实现异步（事件驱动是基于浏览器进程提供的环境，不同的环境基于事件驱动的模型可能不太一样）
       *
       * 所有的异步代码全部是以回调函数的方式出现
       * 并不是所有的回调函数都是异步代码（存在同步回调）
       */

      // 事件循环和异步函数 TODO

      // Call Stack 主线程
      // Event Loop 先看主线程任务有没有执行完成，如果执行完成然后看任务队列，如果任务队列中,如果有任务，那么将任务推入到主线程当中执行代码
      // EventQueue 事件队列

      // HTML5 规定 setTimeout 最低为 0.04ms
      /* console.log(1);
      setTimeout(function () {
        console.log(2);
      }, 0);
      console.log(3); */

      // 1000 会产生一点点偏差，因为同步代码的在执行栈中的阻塞
      /* setTimeout(function () {
        console.log(1);
      }, 1000);
      setTimeout(function () {
        console.log(2);
      });
      console.log(3); */
    </script>
  </body>
</html>
