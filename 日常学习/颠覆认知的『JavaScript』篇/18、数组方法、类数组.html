<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
</html>
<script>
  // ## 面试题
  /* function Foo() {
    getName = function () {
      console.log(1);
    };
    return this;
  }
  Foo.getName = function () {
    console.log(2);
  };
  Foo.prototype.getName = function () {
    console.log(3);
  };
  var getName = function () {
    console.log(4);
  };
  function getName() {
    console.log(5);
  }
  Foo.getName(); // 2，函数的属性可以直接访问
  getName(); // 4，作用域执行的时候，getName: undefind => function(){console.log(5)} => function(){console.log(4)}
  Foo().getName(); // 1，方法执行后函数返回this，普通函数 this 指向 window，函数内 getName 是全局的变量，所以重写了 getName: undefind => function(){console.log(5)} => function(){console.log(4)} => function(){console.log(1)}
  getName(); // 1，因为上面的AO被赋值为了function(){console.log(1)}
  new Foo.getName(); // 2，. 的优先级高于 new ，所以函数访问的是函数的属性
  new Foo().getName(); // 3，() 的优先级比 . 大，函数实例化后返回this对象，this对象指向实例化对象，实例化对象本身没有getName()方法就会到Foo函数的prototype上寻找
  new new Foo().getName(); // 3，先执行 new Foo() 然后 .getName()，最后的 new 语句没有意义
  // https://blog.csdn.net/RedaTao/article/details/107955687 */

  // ==========
  // ## concat 拼接数组，返回拼接后的数组
  /*  var arr1 = ["a", "b", "c"];
  var arr2 = ["d", "e", "f"];
  var arr3 = arr1.concat(arr2);
  console.log(arr3, arr1, arr2); */

  // ## toString 数组转字符串，返回转化后的字符串
  /* var arr = ["a", "b", "c", "d"];
  console.log(arr.toString()); // a,b,c,d */

  // ## slice() 截取数组，返回截取后的数组
  // 参数1: 开始截取的下标
  // 参数2: 结束截取的下标之前，没有参数2会截取到末尾
  // 参数为负数，从末尾开始数
  /* var arr = ["a", "b", "c", "d", "e", "f"];
  var arr1 = arr.slice();
  console.log(arr.slice(1, 3)); */

  // ## join 数组根据符号转化为字符串，返回转化后的字符串
  /* var arr = ["a", "b", "c", "d"];
  var str1 = arr.join(); // 等于 arr.toString()
  var str2 = arr.join("-"); // a-b-c-d

  // split() 是字符串的方法，根据字符把字符串转换为数组
  // 参数1: 字符
  // 参数2: 截取长度
  console.log(str2.split()); // ['a', 'b', 'c', 'd']
  console.log(str2.split("-")); // ['a', 'b', 'c', 'd']
  console.log(str2.split("-", 2)); // ['a', 'b'] */

  // ==========
  // ## 类数组
  /* 
  function test() {
    // 不能用 push 方法肯定没有继承 Array.prototype
    // 类数组的原型是 Object
    // 类数组并不是真正的数组，只是类似数组的对象
    // arguments.push(6); // arguments.push is not a function
    console.log(arguments);
  }
  test(1, 2, 3, 4, 5);

  // 模拟一个类数组
  Array.prototype.myPush = function (num) {
    obj[obj.length] = num;
    this.length++;
  };
  // 类数组必须要有数组形式的下标
  // 必须要有 length 属性
  // 和 splice 方法
  var obj = {
    0: 1,
    1: 2,
    2: 3,
    3: 4,
    4: 5,
    length: 5,
    splice: Array.prototype.splice, // 继承数组的splice会变成数组
    // push: Array.prototype.push,
    push: Array.prototype.myPush,
  };
  obj.push(6);
  console.log(obj); 
  */

  // ## 面试题
  /* var obj = {
    2: 3,
    3: 4,
    length: 2,
    splice: Array.prototype.splice, // splice 方法会让对象变成数组
    push: Array.prototype.push,
  };
  // 因为 push 的原理是 obj[obj.length] ,然后理解成了 obj.2 = 1;
  // 然后 length++
  obj.push(1); // obj[2] = 1;
  obj.push(2); // obj[3] = 2
  console.log(obj); // Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ] */

  // 既有数组的属性又有对象的特性
  /* var person = {
    0: "张小一",
    1: "张小二",
    2: "张小三",
    name: "张三",
    age: 32,
    weight: 140,
    height: 180,
    length: 3,
  };
  Object.prototype.push = Array.prototype.push;
  Object.prototype.splice = Array.prototype.splice;
  console.log(person)
  console.log(person[1])
  console.log(person.weight) */

  // ==========
  // 数组去重
  /* Array.prototype.unique = function () {
    // 数组去重 this
  };
  [].unique() */

  // 封装 typeof , 返回 undefind boolean number string null function array object objectNumber objectBoolean objecString 
  // Object.prototype.toString.call() + typeof()
</script>
